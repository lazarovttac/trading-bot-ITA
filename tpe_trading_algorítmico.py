# -*- coding: utf-8 -*-
"""TPE - Trading Algorítmico (Optimizado)

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1tISF4zz5f0mKRO-4F4QDb8mCWRLCTkXm
"""

!pip install --upgrade backtrader[plotting]

#!pip uninstall matplotlib
#!pip install matplotlib==3.1.1

import yfinance as yf
import backtrader as bt
import itertools
import matplotlib.pyplot as plt
from __future__ import (absolute_import, division, print_function,
                        unicode_literals)
import backtrader.plot as plot

from datetime import datetime, timedelta
import datetime # For datetime objects
import os.path # To manage paths
import sys # To find out the script name (in argv[0])

import pandas as pd

# Descarga la lista del S&P 500 desde Wikipedia
url = "https://en.wikipedia.org/wiki/List_of_S%26P_500_companies"
sp500 = pd.read_html(url, header=0)[0]

# Filtra las empresas del sector tecnológico
tech_companies = sp500[sp500['GICS Sector'] == "Information Technology"]
industrials = sp500[sp500['GICS Sector'] == "Industrials"]
health_care = sp500[sp500['GICS Sector'] == "Health Care"]
utilities = sp500[sp500['GICS Sector'] == "Utilities"]
financials = sp500[sp500['GICS Sector'] == "Financials"]
materials = sp500[sp500['GICS Sector'] == "Materials"]
discretionary = sp500[sp500['GICS Sector'] == "Consumer Discretionary"]
services = sp500[sp500['GICS Sector'] == "Communication Services"]
staples = sp500[sp500['GICS Sector'] == "Consumer Staples"]
real_estate = sp500[sp500['GICS Sector'] == "Real Estate"]
energy = sp500[sp500['GICS Sector'] == "Energy"]

# Obtén los símbolos
symbols = tech_companies['Symbol'].tolist()
# symbols = services['Symbol'].tolist()
symbols = utilities['Symbol'].tolist()
# symbols = real_estate['Symbol'].tolist()

print(f"{len(symbols)} símbolos de las empresas del S&P 500:")
print(symbols)

#Símbolos

# Mezclando buenos rendimientos con malos
# symbols = ["DELL", "QCOM", "WDC", "INTC"]

# symbols = ["DELL"]
# symbols = ["INTC"]
# symbols = ["ENPH"]

# 15 activos relacionados con tecnología con rendimiento negativo
symbols = ["TRMB", "ADBE", "AKAM", "ANSS", "ENPH", "EPAM", "INTC", "KEYS", "MCHP", "QRVO", "SWKS", "TER", "WDC", "ZBRA"]

# symbols = ['ACN', 'ADBE', 'AMD', 'AKAM', 'APH', 'ADI', 'ANSS', 'AAPL', 'AMAT', 'ADSK', 'AVGO', 'CDNS', 'CSCO', 'CTSH', 'GLW', 'DELL', 'ENPH', 'EPAM', 'FFIV', 'FICO', 'FSLR', 'FTNT', 'IT', 'GEN',  'HPQ', 'IBM', 'INTC', 'INTU', 'JBL', 'JNPR', 'KEYS', 'KLAC', 'LRCX', 'MCHP', 'MU', 'MSFT', 'MPWR', 'MSI', 'NTAP', 'NVDA', 'NXPI', 'ON', 'ORCL', 'PANW', 'PTC', 'QRVO', 'QCOM', 'ROP', 'CRM', 'STX', 'NOW', 'SWKS', 'SMCI', 'SNPS', 'TEL', 'TDY', 'TER', 'TXN', 'TRMB', 'TYL', 'VRSN', 'WDC', 'ZBRA']

# Fechas
end_date = datetime.datetime.now()

# Último año
# Un año + 200 ruedas para obtener la media simple de 200
# Para que se desarrollen 200 ruedas se necesitan 290 días de corridos
# start_date = end_date - timedelta(days=(365 + 290))

# Año 2022
# end_date = datetime.date(2023, 1, 1)
# start_date = datetime.date(2022, 1, 1) - timedelta(days=(290))

# Últimos 10 años aproximadamente
start_date = end_date - timedelta(days=(365 * 10 + 290))

# Descarga los datos con yfinance
for symbol in symbols:
  data = yf.download(symbol, start=start_date, end=end_date)
  data.to_csv("data_"+ symbol + ".csv", header=False)

class GenericCSVData(bt.feeds.GenericCSVData):
  params = (
      ('datetime', 0),
      ('time', -1),
      ('open', 5),
      ('high', 3),
      ('low', 4),
      ('close', 2),
      ('volume', 6),
      ('openinterest', -1),
      ('dtformat', '%Y-%m-%d %H:%M:%S%z'),
)

data_feeds = []

for symbol in symbols:
  datapath = os.path.join(os.getcwd(), "data_"+ symbol + ".csv")

  data_feed = GenericCSVData(
      dataname=datapath,
      reverse=False
  )

  data_feeds.append(data_feed)

class CashSizer(bt.Sizer):
    cash = 0

    def set_cash(self, cash):
        self.cash = cash

    def _getsizing(self, comminfo, cash, data, isbuy):
        if isbuy:
            size = int((self.cash * 0.95) / data.close[0])
            return size
        return 0

class TheStrategy(bt.Strategy):
  params = (
      ('min_period', 7),
      ('sma_period', 20),      # Período de la media móvil
      ('trend_sma_period', 200),# Período de la media móvil de tendencia
      ('rsi_period', 9),       # Período del RSI
      ('overbought', 70),      # Nivel de sobrecompra
      ('oversold', 30),        # Nivel de sobreventa
      ('sizer', None),
  )

  def log(self, txt, dt=None):
    dt = dt or self.datas[0].datetime.date(0)
    print('%s, %s' % (dt.isoformat(), txt))

  def __init__(self):
    if self.p.sizer is not None:
          self.sizer = self.p.sizer

    self.cash = []
    self.starting_cash = []

    self.dataclose = []
    self.dataopen = []

    self.sma = []
    self.trend_sma = []
    self.up = []
    self.gone_up = []
    self.rsi = []
    self.min = []
    self.buy_zone = []
    self.bought = []
    self.stop_loss = []

    self.first_close = []

    self.trade_count = 0
    self.revenue_count = 0
    self.stop_loss_count = 0

    self.dynamic_overbought = [self.params.overbought for _ in self.datas]
    self.dynamic_oversold = [self.params.oversold for _ in self.datas]


    for data in self.datas:
      self.first_close.append(0)
      self.gone_up.append(False)

      # Precio de cierre
      self.dataclose.append(data.close)
      # Precio de apertura
      self.dataopen.append(data.open)

      # Media móvil de tendencia
      self.trend_sma.append(bt.indicators.MovingAverageSimple(data, period=self.params.trend_sma_period, plot=False))

      # Media móvil simple
      self.sma.append(bt.indicators.WeightedMovingAverage(data, period=self.params.sma_period, plot=False))

      # RSI
      self.rsi.append(bt.indicators.RSI(data, period=self.params.rsi_period, safediv=True, plot=False))

      # Último mínimo
      self.min.append(bt.indicators.Lowest(data, period=self.params.min_period, plot=False))

      self.buy_zone.append(False)
      self.bought.append(False)
      self.stop_loss.append(0)
      self.up.append(False)

      # Se asignan porciones equitativas del dinero disponible
      # para cada activo, para evaluar el desempeño de la estrategia
      # de forma independiente
      cash = self.broker.getcash() / len(symbols)
      self.cash.append(cash)
      self.starting_cash.append(cash)

  # Manejo de órdenes
  def notify_order(self, order):
    if order.status in [order.Completed]:
        # print("¡Orden completada!")

        symbol = order.data._name
        index = self.datas.index(order.data)
        self.update_cash(index, order, order.executed.price)

        if order.isbuy():
            # Actualizar el efectivo después de la compra
            # self.log(f"COMPRADO {order.executed.size} de {symbol} a {order.executed.price}")
            self.bought[index] = True

            order.data.plotinfo.plotbuy = True  # Marcar compra

        else:
            # Actualizar el efectivo después de la venta
            # self.log(f"VENDIDO {order.executed.size} de {symbol} a {order.executed.price}")
            self.trade_count += 1

            self.bought[index] = False

            order.data.plotinfo.plotsell = True  # Marcar venta


  def next(self):
    for i in range(len(self.datas)):
      try:
          open = self.dataopen[i][1]
          close = self.dataclose[i][1]
      except Exception as e:
          return


      data = self.datas[i]
      symbol = self.datas[i]._name

      # Captura el precio inicial la primera vez que se procesa el activo
      if self.first_close[i] == 0:
          self.log(f"Precio inicial de {symbol}: {data.close[0]}")
          self.first_close[i] = data.close[0]

      # Dinero líquido disponible para invertir en el activo dado
      cash_available = self.cash[i]
      # Cantidad de unidades compradas
      position_size = self.getposition(data).size

      # print(f" --- {symbol} --- ")
      # self.log(' Abre: %.2f' % open)
      # self.log(' Cierra: %.2f' % close)
      # self.log(' Cash: %.2f' % cash_available)
      # self.log(' Position: %.2f' % position_size)

      self.gone_up[i] = self.up[i]

      if close > self.trend_sma[i][1]:
        self.up[i] = True
      else:
        self.up[i] = False

      # Ajustar dinámicamente los niveles RSI según la tendencia
      if self.up[i]:
          self.dynamic_overbought[i] = 70
          self.dynamic_oversold[i] = 40
      else:
          self.dynamic_overbought[i] = 65
          self.dynamic_oversold[i] = 35

      if self.rsi[i][1] >= self.dynamic_overbought[i]:
          self.buy_zone[i] = False
      if self.rsi[i][1] <= self.dynamic_oversold[i]:
          self.buy_zone[i] = True

      # Si todavía no compramos
      if not self.bought[i]:
        # Entrar si estamos en zona de compra y se cruza la media ↗️
        if self.buy_zone[i] and close > self.sma[i][1]:

          self.sizer.set_cash(cash_available)
          # Coloca una orden StopLimit
          # self.log(f"Hago la compra con StopLimit a precio: {close}")
          self.buy(
              data=data,
              exectype=bt.Order.StopLimit,
              stopprice=close,  # Precio de activación
              price=close       # Precio límite
          )

          # self.stop_loss[i] = self.min[i][1]
          self.stop_loss[i] = close * 0.98 # Corta la pérdida más rápido -> rinde mejor

      # Salir si se llega al stoploss
      if self.bought[i] and close <= self.stop_loss[i]:
        self.stop_loss_count += 1
        self.sell(data=data, size=position_size)

        # print(f" -> STOP LOSS!")

      # Si ya hemos comprado y estamos en zona de venta
      if self.bought[i] and not self.buy_zone[i]:
        # Salir si se cruza la media ↘️
        if close < self.sma[i][1]:
            self.revenue_count += 1
            self.sell(data=data, size=position_size)

            # print(f" -> Toma de ganancia!")

        elif self.gone_up[i] and not self.up[i]:
          self.revenue_count += 1
          self.sell(data=data, size=position_size)

          # print(f" -> Toma de ganancia! (trend_sma)")


  def update_cash(self, index, order, executed_price):
    self.cash[index] -= executed_price * order.executed.size + order.executed.comm


  def stop(self):
      # Calcular el rendimiento de buy and hold para cada activo
      for i, data in enumerate(self.datas):
          first_price = self.first_close[i]
          last_price = data.close[0]  # Precio final disponible
          performance = ((last_price - first_price) / first_price) * 100
          bot_performance = (((self.cash[i] + self.getposition(data=data).size * self.dataclose[i][0])- self.starting_cash[i]) / self.starting_cash[i]) * 100

          performances.append(performance)
          bot_performances.append(bot_performance)

          print(f"Rendimiento de {data._name}: {performance:.2f}%")
          print(f"Rendimiento del bot en {data._name}: {bot_performance:.2f}%")

# Crea el cerebro
cerebro = bt.Cerebro(stdstats=False)

performances = []
bot_performances = []

# Añade los datos
for data_feed in data_feeds:
  cerebro.adddata(data_feed)

starting_cash = 100000.0
sizer=CashSizer()

# Se añade la estrategia y el sizer
cerebro.addstrategy(TheStrategy, sma_period=20, trend_sma_period=200, rsi_period=14, overbought=60, oversold=30, sizer=sizer, min_period=10)

# Define dinero disponible y comisión
cerebro.broker.setcash(starting_cash)
cerebro.broker.setcommission(commission=0.001)

print('Starting Portfolio Value: %.2f' % cerebro.broker.getvalue())
strategies = cerebro.run()
print('Final Portfolio Value: %.2f' % cerebro.broker.getvalue())
print(f"____________________________________")

print(f"Rendimiento promedio de los activos: {sum(performances) / len(performances)}%")
print(f"Rendimiento del bot en base a los activos: {sum(bot_performances) / len(bot_performances)}%")
print(f"Rendimiento del bot: {((cerebro.broker.getvalue() - starting_cash) / starting_cash) * 100}%")

print(f"____________________________________")
print(f"Se realizaron {strategies[0].trade_count} trades")
print(f"Se obtuvieron ganancias en {strategies[0].revenue_count} trades")
print(f"Se obtuvieron pérdidas en {strategies[0].stop_loss_count} trades")

# for i in range(len(cerebro.datas)):
#   # Accede a la primera figura dentro de la lista (índice 0)
#   figure = cerebro.plot(data=cerebro.datas[i], style='candlestick',
#                         plotinfo=dict(
#                               plot_buysell=True,
#                               plot_data=True,
#                               plot_indicators=False
#                         )
#                         )[0][0]
#   figure.savefig(f"grafico_{symbols[i]}.png")